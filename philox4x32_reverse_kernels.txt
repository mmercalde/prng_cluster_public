
PHILOX4X32_REVERSE_KERNEL = r'''
extern "C" __global__
void philox4x32_reverse_sieve(
    unsigned long long* candidate_seeds, unsigned int* residues, unsigned long long* survivors,
    float* match_rates, unsigned char* best_skips, unsigned int* survivor_count,
    int n_candidates, int k, int skip_min, int skip_max, float threshold, int offset
) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    if (idx >= n_candidates) return;
    
    unsigned long long seed = candidate_seeds[idx];
    unsigned int key0 = (unsigned int)(seed & 0xFFFFFFFF);
    unsigned int key1 = (unsigned int)((seed >> 32) & 0xFFFFFFFF);
    
    // Hardcoded Philox4x32 constants
    const unsigned int PHILOX_M4x32_0 = 0xD2511F53;
    const unsigned int PHILOX_M4x32_1 = 0xCD9E8D57;
    const unsigned int PHILOX_W32_0 = 0x9E3779B9;
    const unsigned int PHILOX_W32_1 = 0xBB67AE85;
    
    auto philox_generate = [&](unsigned int counter) -> unsigned int {
        unsigned int ctr[4] = {counter, 0, 0, 0};
        unsigned int k_local[2] = {key0, key1};
        
        for (int round = 0; round < 10; round++) {
            unsigned long long prod0 = (unsigned long long)ctr[0] * PHILOX_M4x32_0;
            unsigned long long prod1 = (unsigned long long)ctr[2] * PHILOX_M4x32_1;
            unsigned int hi0 = (unsigned int)(prod0 >> 32);
            unsigned int lo0 = (unsigned int)(prod0 & 0xFFFFFFFF);
            unsigned int hi1 = (unsigned int)(prod1 >> 32);
            unsigned int lo1 = (unsigned int)(prod1 & 0xFFFFFFFF);
            
            ctr[0] = hi1 ^ ctr[1] ^ k_local[0];
            ctr[1] = lo1;
            ctr[2] = hi0 ^ ctr[3] ^ k_local[1];
            ctr[3] = lo0;
            
            k_local[0] += PHILOX_W32_0;
            k_local[1] += PHILOX_W32_1;
        }
        return ctr[0];
    };
    
    float best_rate = 0.0f;
    int best_skip_val = 0;
    
    for (int skip = skip_min; skip <= skip_max; skip++) {
        unsigned int counter = offset + skip;
        int matches = 0;
        
        for (int i = 0; i < k; i++) {
            unsigned int output = philox_generate(counter);
            
            // Multi-modulo validation
            if (((output % 1000) == (residues[i] % 1000)) &&
                ((output % 8) == (residues[i] % 8)) &&
                ((output % 125) == (residues[i] % 125))) {
                matches++;
            }
            
            counter += skip + 1;
        }
        
        float rate = ((float)matches) / ((float)k);
        if (rate > best_rate) {
            best_rate = rate;
            best_skip_val = skip;
        }
    }
    
    if (best_rate >= threshold) {
        unsigned int pos = atomicAdd(survivor_count, 1);
        survivors[pos] = candidate_seeds[idx];
        match_rates[pos] = best_rate;
        best_skips[pos] = (unsigned char)best_skip_val;
    }
}
'''

PHILOX4X32_HYBRID_REVERSE_KERNEL = r'''
extern "C" __global__
void philox4x32_hybrid_reverse_sieve(
    unsigned long long* candidate_seeds, unsigned int* residues, unsigned long long* survivors,
    float* match_rates, unsigned int* skip_sequences, unsigned int* strategy_ids,
    unsigned int* survivor_count, int n_candidates, int k,
    int* strategy_max_misses, int* strategy_tolerances, int n_strategies,
    float threshold, int offset
) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    if (idx >= n_candidates) return;
    
    unsigned long long seed = candidate_seeds[idx];
    unsigned int key0 = (unsigned int)(seed & 0xFFFFFFFF);
    unsigned int key1 = (unsigned int)((seed >> 32) & 0xFFFFFFFF);
    
    // Hardcoded Philox4x32 constants
    const unsigned int PHILOX_M4x32_0 = 0xD2511F53;
    const unsigned int PHILOX_M4x32_1 = 0xCD9E8D57;
    const unsigned int PHILOX_W32_0 = 0x9E3779B9;
    const unsigned int PHILOX_W32_1 = 0xBB67AE85;
    
    auto philox_generate = [&](unsigned int counter) -> unsigned int {
        unsigned int ctr[4] = {counter, 0, 0, 0};
        unsigned int k_local[2] = {key0, key1};
        
        for (int round = 0; round < 10; round++) {
            unsigned long long prod0 = (unsigned long long)ctr[0] * PHILOX_M4x32_0;
            unsigned long long prod1 = (unsigned long long)ctr[2] * PHILOX_M4x32_1;
            unsigned int hi0 = (unsigned int)(prod0 >> 32);
            unsigned int lo0 = (unsigned int)(prod0 & 0xFFFFFFFF);
            unsigned int hi1 = (unsigned int)(prod1 >> 32);
            unsigned int lo1 = (unsigned int)(prod1 & 0xFFFFFFFF);
            
            ctr[0] = hi1 ^ ctr[1] ^ k_local[0];
            ctr[1] = lo1;
            ctr[2] = hi0 ^ ctr[3] ^ k_local[1];
            ctr[3] = lo0;
            
            k_local[0] += PHILOX_W32_0;
            k_local[1] += PHILOX_W32_1;
        }
        return ctr[0];
    };
    
    for (int strat_id = 0; strat_id < n_strategies; strat_id++) {
        int max_consecutive_misses = strategy_max_misses[strat_id];
        int skip_tolerance = strategy_tolerances[strat_id];
        
        unsigned int counter = offset;
        int matches = 0;
        int consecutive_misses = 0;
        unsigned int skip_seq[512];
        bool failed = false;
        
        for (int i = 0; i < k && !failed; i++) {
            bool found = false;
            
            for (int try_skip = 0; try_skip <= skip_tolerance && !found; try_skip++) {
                unsigned int test_counter = counter + try_skip;
                unsigned int output = philox_generate(test_counter);
                
                // Multi-modulo test
                if (((output % 1000) == (residues[i] % 1000)) &&
                    ((output % 8) == (residues[i] % 8)) &&
                    ((output % 125) == (residues[i] % 125))) {
                    found = true;
                    matches++;
                    consecutive_misses = 0;
                    skip_seq[i] = try_skip;
                    counter = test_counter + 1;
                }
            }
            
            if (!found) {
                consecutive_misses++;
                if (consecutive_misses > max_consecutive_misses) {
                    failed = true;
                }
                skip_seq[i] = 0;
                counter++;
            }
        }
        
        if (!failed) {
            float rate = ((float)matches) / ((float)k);
            
            if (rate >= threshold) {
                int pos = atomicAdd(survivor_count, 1);
                survivors[pos] = candidate_seeds[idx];
                match_rates[pos] = rate;
                strategy_ids[pos] = strat_id;
                
                for (int i = 0; i < k; i++) {
                    skip_sequences[pos * 512 + i] = skip_seq[i];
                }
                
                return;
            }
        }
    }
}
'''

