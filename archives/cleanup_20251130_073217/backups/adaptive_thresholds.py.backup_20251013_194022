"""
Adaptive threshold estimation for hybrid PRNG search
Estimates background match rates to set Phase 1 and Phase 2 thresholds automatically
"""

import statistics
from typing import Tuple, List

def estimate_background_thresholds(
    draws: List[int],
    generate_sequence_func,
    seed_start: int,
    seed_end: int,
    skip_range: Tuple[int, int],
    k: int,
    max_pilot_seeds: int = 128
) -> Tuple[float, float]:
    """
    Probe a small seed subset to estimate background match-rate distribution.
    
    Args:
        draws: Target draw sequence to match against
        generate_sequence_func: Function(seed, k, skip) -> List[int]
        seed_start: Start of seed range
        seed_end: End of seed range
        skip_range: (min_skip, max_skip) tuple
        k: Window size
        max_pilot_seeds: Number of random seeds to sample
    
    Returns:
        (phase1_threshold, phase2_threshold) tuple
    """
    lo, hi = seed_start, seed_end
    total = max(0, hi - lo)
    
    if total == 0:
        return 0.15, 0.70  # Fallback defaults
    
    # For very small ranges, use conservative defaults
    if total < 100:
        # Very permissive Phase 1 for small searches
        return 0.001, 0.60
    
    # Sample seeds evenly across range
    step = max(1, total // max_pilot_seeds)
    sample_seeds = list(range(lo, min(hi, lo + step * max_pilot_seeds), step))
    
    if not sample_seeds:
        sample_seeds = [lo]
    
    # Use middle skip value for pilot
    smin, smax = skip_range
    rep_skip = (smin + smax) // 2
    
    rates = []
    
    for seed in sample_seeds:
        try:
            # Generate candidate sequence
            candidate = generate_sequence_func(seed, k, rep_skip)
            
            # Calculate match rate
            matches = sum(1 for a, b in zip(candidate, draws) if a == b)
            rate = matches / float(k)
            rates.append(rate)
            
        except Exception as e:
            # Skip problematic seeds
            continue
    
    if not rates:
        return 0.15, 0.70  # Fallback defaults
    
    # Calculate statistics
    mu = statistics.mean(rates)
    sd = statistics.pstdev(rates) if len(rates) > 1 else 0.0
    top = max(rates)
    
    # Phase 1: mean + nσ, clamped to reasonable range
    # For small samples (< 50), be more conservative (2σ instead of 3σ)
    if len(rates) < 50:
        phase1 = max(0.001, min(0.20, mu + 2.0 * sd))
    else:
        phase1 = max(0.005, min(0.25, mu + 3.0 * sd))
    
    # Phase 2: Must be significantly above phase1
    # Use the higher of: fixed bump or 90% of best pilot match
    phase2_option_a = phase1 + 0.25
    phase2_option_b = top * 0.85 if top > phase1 else phase2_option_a
    phase2 = max(0.60, min(0.90, max(phase2_option_a, phase2_option_b)))
    
    return round(phase1, 3), round(phase2, 3)


def coerce_threshold(val, default: float = 0.20):
    """
    Convert threshold value to float, handling 'auto' string.
    
    Args:
        val: Threshold value (float, int, str, or None)
        default: Default value if parsing fails
    
    Returns:
        Float threshold value, or 'auto' string
    """
    if val is None:
        return 'auto'
    
    if isinstance(val, (int, float)):
        return float(val)
    
    s = str(val).strip().lower()
    if s == 'auto':
        return 'auto'
    
    try:
        return float(s)
    except (ValueError, TypeError):
        return default
