#!/usr/bin/env python3
"""
Adaptive Window Optimizer - Finds optimal window configuration
Modular design with pluggable search strategies for ML/AI integration
"""

import json
import numpy as np
from typing import Callable, Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from abc import ABC, abstractmethod
import random

# ============================================================================
# DATA STRUCTURES
# ============================================================================

@dataclass
class WindowConfig:
    """Complete window and skip configuration"""
    window_size: int
    offset: int
    sessions: List[str]
    skip_min: int
    skip_max: int
    
    def __hash__(self):
        return hash((self.window_size, self.offset, tuple(self.sessions), 
                    self.skip_min, self.skip_max))
    
    def description(self) -> str:
        sess = '+'.join(self.sessions)
        return f"W{self.window_size}_O{self.offset}_{sess}_S{self.skip_min}-{self.skip_max}"
    
    def to_dict(self) -> Dict:
        return asdict(self)

@dataclass
class SearchBounds:
    """Search space boundaries"""
    min_window_size: int = 128
    max_window_size: int = 4096
    min_offset: int = 0
    max_offset: int = 2000
    min_skip_min: int = 0
    max_skip_min: int = 200
    min_skip_max: int = 0
    max_skip_max: int = 500
    session_options: List[List[str]] = None
    
    def __post_init__(self):
        if self.session_options is None:
            self.session_options = [
                ['midday', 'evening'],
                ['midday'],
                ['evening']
            ]
    
    def random_config(self) -> WindowConfig:
        """Generate random config within bounds"""
        skip_min = random.randint(self.min_skip_min, self.max_skip_min)
        skip_max = random.randint(skip_min, self.max_skip_max)
        
        return WindowConfig(
            window_size=random.randint(self.min_window_size, self.max_window_size),
            offset=random.randint(self.min_offset, self.max_offset),
            sessions=random.choice(self.session_options),
            skip_min=skip_min,
            skip_max=skip_max
        )
    
    def is_valid(self, config: WindowConfig) -> bool:
        """Check if config is within bounds"""
        return (self.min_window_size <= config.window_size <= self.max_window_size and
                self.min_offset <= config.offset <= self.max_offset and
                self.min_skip_min <= config.skip_min <= self.max_skip_min and
                config.skip_min <= config.skip_max <= self.max_skip_max and
                config.sessions in self.session_options)

@dataclass
class TestResult:
    """Result from testing a window configuration"""
    config: WindowConfig
    forward_count: int
    reverse_count: int
    bidirectional_count: int
    iteration: int
    
    @property
    def precision(self) -> float:
        return self.bidirectional_count / self.forward_count if self.forward_count > 0 else 0
    
    @property
    def recall(self) -> float:
        return self.bidirectional_count / self.reverse_count if self.reverse_count > 0 else 0
    
    def to_dict(self) -> Dict:
        """Convert to serializable dict"""
        return {
            'config': self.config.to_dict(),
            'forward_count': self.forward_count,
            'reverse_count': self.reverse_count,
            'bidirectional_count': self.bidirectional_count,
            'precision': self.precision,
            'recall': self.recall,
            'iteration': self.iteration
        }

# ============================================================================
# SCORING FUNCTIONS
# ============================================================================

class ScoringFunction(ABC):
    """Base class for scoring functions"""
    
    @abstractmethod
    def score(self, result: TestResult) -> float:
        pass
    
    @abstractmethod
    def name(self) -> str:
        pass

class BidirectionalCountScorer(ScoringFunction):
    """Simple count of bidirectional survivors"""
    def score(self, result: TestResult) -> float:
        return float(result.bidirectional_count)
    
    def name(self) -> str:
        return "bidirectional_count"

# ============================================================================
# SEARCH STRATEGIES
# ============================================================================

class SearchStrategy(ABC):
    """Base class for search strategies"""
    
    @abstractmethod
    def search(self, 
               objective_function: Callable[[WindowConfig], TestResult],
               bounds: SearchBounds,
               max_iterations: int,
               scorer: ScoringFunction) -> Dict[str, Any]:
        pass
    
    @abstractmethod
    def name(self) -> str:
        pass

class RandomSearch(SearchStrategy):
    """Random search baseline"""
    
    def search(self, objective_function, bounds, max_iterations, scorer):
        print(f"\n{'='*80}")
        print(f"ðŸŽ² RANDOM SEARCH")
        print(f"Max iterations: {max_iterations}")
        print(f"{'='*80}\n")
        
        results = []
        best_result = None
        best_score = float('-inf')
        
        for i in range(max_iterations):
            config = bounds.random_config()
            result = objective_function(config)
            result.iteration = i
            score = scorer.score(result)
            results.append(result)
            
            if score > best_score:
                best_score = score
                best_result = result
                print(f"âœ¨ NEW BEST [{i+1}/{max_iterations}]: {config.description()}")
                print(f"   Bidirectional: {result.bidirectional_count}, Score: {score:.2f}\n")
            else:
                print(f"   [{i+1}/{max_iterations}] {config.description()}: {result.bidirectional_count}")
        
        return {
            'strategy': self.name(),
            'best_config': best_result.config.to_dict(),
            'best_result': best_result.to_dict(),
            'best_score': best_score,
            'all_results': [r.to_dict() for r in results],
            'iterations': len(results)
        }
    
    def name(self) -> str:
        return "random_search"

class GridSearch(SearchStrategy):
    """Grid search"""
    
    def __init__(self, window_sizes=None, offsets=None, skip_ranges=None):
        self.window_sizes = window_sizes or [512, 768, 1024]
        self.offsets = offsets or [0, 100]
        self.skip_ranges = skip_ranges or [(0, 20), (0, 50)]
    
    def search(self, objective_function, bounds, max_iterations, scorer):
        print(f"\n{'='*80}")
        print(f"ðŸ”² GRID SEARCH")
        print(f"{'='*80}\n")
        
        results = []
        best_result = None
        best_score = float('-inf')
        iteration = 0
        
        for size in self.window_sizes:
            for offset in self.offsets:
                for sessions in bounds.session_options:
                    for skip_min, skip_max in self.skip_ranges:
                        if iteration >= max_iterations:
                            break
                        
                        config = WindowConfig(size, offset, sessions, skip_min, skip_max)
                        result = objective_function(config)
                        result.iteration = iteration
                        score = scorer.score(result)
                        results.append(result)
                        
                        if score > best_score:
                            best_score = score
                            best_result = result
                            print(f"âœ¨ NEW BEST [{iteration+1}]: {config.description()}")
                            print(f"   Bidirectional: {result.bidirectional_count}\n")
                        
                        iteration += 1
        
        return {
            'strategy': self.name(),
            'best_config': best_result.config.to_dict(),
            'best_result': best_result.to_dict(),
            'best_score': best_score,
            'all_results': [r.to_dict() for r in results],
            'iterations': len(results)
        }
    
    def name(self) -> str:
        return "grid_search"

class BayesianOptimization(SearchStrategy):
    """Bayesian optimization (simplified version)"""
    
    def __init__(self, n_initial=5):
        self.n_initial = n_initial
    
    def search(self, objective_function, bounds, max_iterations, scorer):
        print(f"\n{'='*80}")
        print(f"ðŸ§  BAYESIAN OPTIMIZATION (Simplified)")
        print(f"{'='*80}\n")
        
        # Fallback to random search for simplicity
        return RandomSearch().search(objective_function, bounds, max_iterations, scorer)
    
    def name(self) -> str:
        return "bayesian_optimization"

class EvolutionarySearch(SearchStrategy):
    """Evolutionary algorithm"""
    
    def __init__(self, population_size=10, mutation_rate=0.2):
        self.population_size = population_size
        self.mutation_rate = mutation_rate
    
    def search(self, objective_function, bounds, max_iterations, scorer):
        print(f"\n{'='*80}")
        print(f"ðŸ§¬ EVOLUTIONARY SEARCH")
        print(f"{'='*80}\n")
        
        # Simplified - fallback to random
        return RandomSearch().search(objective_function, bounds, max_iterations, scorer)
    
    def name(self) -> str:
        return "evolutionary"

# ============================================================================
# MAIN OPTIMIZER
# ============================================================================

class WindowOptimizer:
    """Main optimizer class"""
    
    def __init__(self, coordinator, dataset_path: str):
        self.coordinator = coordinator
        self.dataset_path = dataset_path
        self.test_cache = {}
    
    def test_configuration(self, config: WindowConfig, seed_start: int = 0,
                          seed_count: int = 10_000_000, threshold: float = 0.01) -> TestResult:
        """Test a configuration - PLACEHOLDER"""
        # This will be overridden by integration layer
        return TestResult(
            config=config,
            forward_count=random.randint(100, 200),
            reverse_count=random.randint(100, 200),
            bidirectional_count=random.randint(0, 50),
            iteration=0
        )
    
    def optimize(self, strategy: SearchStrategy, bounds: SearchBounds,
                max_iterations: int = 50, scorer: ScoringFunction = None,
                seed_start: int = 0, seed_count: int = 10_000_000,
                threshold: float = 0.01) -> Dict[str, Any]:
        """Run optimization"""
        if scorer is None:
            scorer = BidirectionalCountScorer()
        
        def objective(config: WindowConfig) -> TestResult:
            return self.test_configuration(config, seed_start, seed_count, threshold)
        
        return strategy.search(objective, bounds, max_iterations, scorer)
    
    def save_results(self, results: Dict[str, Any], output_path: str):
        """Save results"""
        with open(output_path, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nâœ… Results saved to: {output_path}")

