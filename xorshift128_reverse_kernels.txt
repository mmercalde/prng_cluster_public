
XORSHIFT128_REVERSE_KERNEL = r'''
extern "C" __global__
void xorshift128_reverse_sieve(
    unsigned int* candidate_seeds, unsigned int* residues, unsigned int* survivors,
    float* match_rates, unsigned char* best_skips, unsigned int* survivor_count,
    int n_candidates, int k, int skip_min, int skip_max, float threshold, int offset
) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    if (idx >= n_candidates) return;
    
    unsigned int seed = candidate_seeds[idx];
    float best_rate = 0.0f;
    int best_skip_val = 0;
    
    for (int skip = skip_min; skip <= skip_max; skip++) {
        unsigned int x = seed;
        unsigned int y = 362436069;
        unsigned int z = 521288629;
        unsigned int w = 88675123;
        
        // Pre-advance by offset
        for (int o = 0; o < offset; o++) {
            unsigned int t = x ^ (x << 11);
            x = y; y = z; z = w;
            w = w ^ (w >> 19) ^ (t ^ (t >> 8));
        }
        
        // Burn skip values before first draw
        for (int s = 0; s < skip; s++) {
            unsigned int t = x ^ (x << 11);
            x = y; y = z; z = w;
            w = w ^ (w >> 19) ^ (t ^ (t >> 8));
        }
        
        int matches = 0;
        for (int i = 0; i < k; i++) {
            // Generate draw
            unsigned int t = x ^ (x << 11);
            x = y; y = z; z = w;
            w = w ^ (w >> 19) ^ (t ^ (t >> 8));
            
            // Multi-modulo validation
            if (((w % 1000) == (unsigned int)(residues[i] % 1000)) &&
                ((w % 8) == (unsigned int)(residues[i] % 8)) &&
                ((w % 125) == (unsigned int)(residues[i] % 125))) {
                matches++;
            }
            
            // Skip between draws
            for (int s = 0; s < skip; s++) {
                t = x ^ (x << 11);
                x = y; y = z; z = w;
                w = w ^ (w >> 19) ^ (t ^ (t >> 8));
            }
        }
        
        float rate = ((float)matches) / ((float)k);
        if (rate > best_rate) {
            best_rate = rate;
            best_skip_val = skip;
        }
    }
    
    if (best_rate >= threshold) {
        unsigned int pos = atomicAdd(survivor_count, 1);
        survivors[pos] = candidate_seeds[idx];
        match_rates[pos] = best_rate;
        best_skips[pos] = (unsigned char)best_skip_val;
    }
}
'''

XORSHIFT128_HYBRID_REVERSE_KERNEL = r'''
extern "C" __global__
void xorshift128_hybrid_reverse_sieve(
    unsigned int* candidate_seeds, unsigned int* residues, unsigned int* survivors,
    float* match_rates, unsigned int* skip_sequences, unsigned int* strategy_ids,
    unsigned int* survivor_count, int n_candidates, int k,
    int* strategy_max_misses, int* strategy_tolerances, int n_strategies,
    float threshold, int offset
) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    if (idx >= n_candidates) return;
    
    unsigned int seed = candidate_seeds[idx];
    
    for (int strat_id = 0; strat_id < n_strategies; strat_id++) {
        int max_consecutive_misses = strategy_max_misses[strat_id];
        int skip_tolerance = strategy_tolerances[strat_id];
        
        unsigned int x = seed;
        unsigned int y = 362436069;
        unsigned int z = 521288629;
        unsigned int w = 88675123;
        
        // Pre-advance by offset
        for (int o = 0; o < offset; o++) {
            unsigned int t = x ^ (x << 11);
            x = y; y = z; z = w;
            w = w ^ (w >> 19) ^ (t ^ (t >> 8));
        }
        
        int matches = 0;
        int consecutive_misses = 0;
        unsigned int skip_seq[512];
        bool failed = false;
        
        for (int i = 0; i < k && !failed; i++) {
            bool found = false;
            
            for (int try_skip = 0; try_skip <= skip_tolerance && !found; try_skip++) {
                unsigned int x_save = x;
                unsigned int y_save = y;
                unsigned int z_save = z;
                unsigned int w_save = w;
                
                // Apply trial skip
                for (int s = 0; s < try_skip; s++) {
                    unsigned int t = x ^ (x << 11);
                    x = y; y = z; z = w;
                    w = w ^ (w >> 19) ^ (t ^ (t >> 8));
                }
                
                // Generate next value
                unsigned int t = x ^ (x << 11);
                x = y; y = z; z = w;
                w = w ^ (w >> 19) ^ (t ^ (t >> 8));
                
                // Multi-modulo test
                if (((w % 1000) == (unsigned int)(residues[i] % 1000)) &&
                    ((w % 8) == (unsigned int)(residues[i] % 8)) &&
                    ((w % 125) == (unsigned int)(residues[i] % 125))) {
                    found = true;
                    matches++;
                    consecutive_misses = 0;
                    skip_seq[i] = try_skip;
                } else {
                    x = x_save;
                    y = y_save;
                    z = z_save;
                    w = w_save;
                }
            }
            
            if (!found) {
                consecutive_misses++;
                if (consecutive_misses > max_consecutive_misses) {
                    failed = true;
                }
                skip_seq[i] = 0;
            }
        }
        
        if (!failed) {
            float rate = ((float)matches) / ((float)k);
            
            if (rate >= threshold) {
                int pos = atomicAdd(survivor_count, 1);
                survivors[pos] = candidate_seeds[idx];
                match_rates[pos] = rate;
                strategy_ids[pos] = strat_id;
                
                for (int i = 0; i < k; i++) {
                    skip_sequences[pos * 512 + i] = skip_seq[i];
                }
                
                return;
            }
        }
    }
}
'''

