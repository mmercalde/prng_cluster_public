
XORSHIFT32_REVERSE_KERNEL = r'''
extern "C" __global__
void xorshift32_reverse_sieve(
    unsigned int* candidate_seeds, unsigned int* residues, unsigned int* survivors,
    float* match_rates, unsigned char* best_skips, unsigned int* survivor_count,
    int n_candidates, int k, int skip_min, int skip_max, float threshold, int offset
) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    if (idx >= n_candidates) return;

    // HARDCODE params (from default_params)
    const int shift_a = 13;
    const int shift_b = 17;
    const int shift_c = 5;

    unsigned int seed = candidate_seeds[idx];
    float best_rate = 0.0f;
    int best_skip_val = 0;

    for (int skip = skip_min; skip <= skip_max; skip++) {
        unsigned int state = seed;

        // Pre-advance by offset
        for (int o = 0; o < offset; o++) {
            state ^= state << shift_a;
            state ^= state >> shift_b;
            state ^= state << shift_c;
        }

        // Burn skip values before first draw
        for (int s = 0; s < skip; s++) {
            state ^= state << shift_a;
            state ^= state >> shift_b;
            state ^= state << shift_c;
        }

        int matches = 0;
        for (int i = 0; i < k; i++) {
            // Generate output
            state ^= state << shift_a;
            state ^= state >> shift_b;
            state ^= state << shift_c;

            if (((state % 1000) == (unsigned int)(residues[i] % 1000)) &&
                ((state % 8) == (unsigned int)(residues[i] % 8)) &&
                ((state % 125) == (unsigned int)(residues[i] % 125))) matches++;

            // Skip between draws
            for (int s = 0; s < skip; s++) {
                state ^= state << shift_a;
                state ^= state >> shift_b;
                state ^= state << shift_c;
            }
        }

        float rate = ((float)matches) / ((float)k);
        if (rate > best_rate) {
            best_rate = rate;
            best_skip_val = skip;
        }
    }

    if (best_rate >= threshold) {
        unsigned int pos = atomicAdd(survivor_count, 1);
        survivors[pos] = candidate_seeds[idx];
        match_rates[pos] = best_rate;
        best_skips[pos] = (unsigned char)best_skip_val;
    }
}
'''

XORSHIFT32_HYBRID_REVERSE_KERNEL = r'''
extern "C" __global__
void xorshift32_hybrid_reverse_sieve(
    unsigned int* candidate_seeds, unsigned int* residues, unsigned int* survivors,
    float* match_rates, unsigned int* skip_sequences, unsigned int* strategy_ids,
    unsigned int* survivor_count, int n_candidates, int k,
    int* strategy_max_misses, int* strategy_tolerances, int n_strategies,
    float threshold, int offset
) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    if (idx >= n_candidates) return;

    // HARDCODE params
    const int shift_a = 13;
    const int shift_b = 17;
    const int shift_c = 5;

    unsigned int seed = candidate_seeds[idx];

    float best_match_rate = 0.0f;
    int best_strategy_id = 0;
    unsigned int best_skip_seq[512];

    // Test each strategy
    for (int strat_id = 0; strat_id < n_strategies; strat_id++) {
        int max_misses = strategy_max_misses[strat_id];
        int skip_tolerance = strategy_tolerances[strat_id];

        // Initialize state
        unsigned int state = seed;

        // Apply offset
        for (int o = 0; o < offset; o++) {
            state ^= state << shift_a;
            state ^= state >> shift_b;
            state ^= state << shift_c;
        }

        int matches = 0;
        int consecutive_misses = 0;
        int expected_skip = 5;
        unsigned int current_skip_seq[512];

        for (int draw_idx = 0; draw_idx < k && draw_idx < 512; draw_idx++) {
            // Backup state
            unsigned int state_backup = state;

            bool found = false;
            int actual_skip = expected_skip;

            int search_min = (expected_skip > skip_tolerance) ? (expected_skip - skip_tolerance) : 0;
            int search_max = expected_skip + skip_tolerance;

            // Try different skip values
            for (int test_skip = search_min; test_skip <= search_max; test_skip++) {
                // Restore state
                state = state_backup;

                // Advance state test_skip times
                for (int j = 0; j < test_skip; j++) {
                    state ^= state << shift_a;
                    state ^= state >> shift_b;
                    state ^= state << shift_c;
                }

                // Generate output
                unsigned int temp_state = state;
                temp_state ^= temp_state << shift_a;
                temp_state ^= temp_state >> shift_b;
                temp_state ^= temp_state << shift_c;
                unsigned int output = temp_state;

                // Check 3-lane match
                if (((output % 1000) == (unsigned int)(residues[draw_idx] % 1000)) &&
                    ((output % 8) == (unsigned int)(residues[draw_idx] % 8)) &&
                    ((output % 125) == (unsigned int)(residues[draw_idx] % 125))) {
                    matches++;
                    consecutive_misses = 0;
                    actual_skip = test_skip;
                    expected_skip = test_skip;
                    found = true;
                    state = temp_state;
                    break;
                }
            }

            if (draw_idx < 512) current_skip_seq[draw_idx] = actual_skip;

            if (!found) {
                consecutive_misses++;
                if (consecutive_misses >= max_misses) break;
            }
        }

        // Calculate match rate
        float match_rate = (float)matches / k;

        // Update best strategy
        if (match_rate > best_match_rate) {
            best_match_rate = match_rate;
            best_strategy_id = strat_id;
            for (int i = 0; i < k && i < 512; i++) {
                best_skip_seq[i] = current_skip_seq[i];
            }
        }
    }

    // Store survivor if above threshold
    if (best_match_rate >= threshold) {
        int pos = atomicAdd(survivor_count, 1);
        if (pos < n_candidates) {
            survivors[pos] = candidate_seeds[idx];
            match_rates[pos] = best_match_rate;
            strategy_ids[pos] = best_strategy_id;
            int seq_size = (k < 512) ? k : 512;
            for (int i = 0; i < seq_size; i++) {
                skip_sequences[pos * 512 + i] = best_skip_seq[i];
            }
        }
    }
}
'''

